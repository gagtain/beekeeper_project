import { parseURL, withLeadingSlash } from 'ufo';
import { useNitro, useNuxt, createResolver, resolvePath, defineNuxtModule, addImports, addComponent, addTemplate, addPlugin } from '@nuxt/kit';
import { resolve, relative, normalize } from 'pathe';
import { defu } from 'defu';
import { hash } from 'ohash';
import { provider } from 'std-env';
import { eventHandler } from 'h3';

const ipxSetup = async (providerOptions, moduleOptions) => {
  const nitro = useNitro();
  const nuxt = useNuxt();
  const hasUserProvidedIPX = nuxt.options.serverHandlers.find((handler) => handler.route?.startsWith("/_ipx")) || nuxt.options.devServerHandlers.find((handler) => handler.route?.startsWith("/_ipx"));
  if (hasUserProvidedIPX) {
    return;
  }
  const ipxOptions = {
    dir: resolve(nuxt.options.srcDir, moduleOptions.dir || nuxt.options.dir.public),
    maxAge: providerOptions.options?.maxAge,
    domains: moduleOptions.domains,
    sharp: moduleOptions.sharp,
    alias: moduleOptions.alias
  };
  if (!nuxt.options.dev) {
    const resolver = createResolver(import.meta.url);
    nitro.options._config.runtimeConfig = nitro.options._config.runtimeConfig || {};
    nitro.options._config.runtimeConfig.ipx = { ...ipxOptions };
    ipxOptions.dir = relative(nitro.options.output.serverDir, nitro.options.output.publicDir);
    nitro.options.runtimeConfig.ipx = ipxOptions;
    const handler = {
      route: "/_ipx/**",
      handler: resolver.resolve("./runtime/ipx")
    };
    nitro.options.handlers.push(handler);
    nitro.options._config.handlers.push(handler);
    return;
  }
  const { createIPX, createIPXMiddleware } = await import('ipx').catch((err) => {
    console.error("[@nuxt/image] `ipx` is an optional dependency for local image optimization and is not installed.");
    throw new Error(err);
  });
  const ipx = createIPX(ipxOptions);
  const middleware = createIPXMiddleware(ipx);
  const devHandler = {
    route: "/_ipx",
    handler: eventHandler(async (event) => {
      await middleware(event.node.req, event.node.res);
    })
  };
  nitro.options.devHandlers.push(devHandler);
  nitro.options._config.devHandlers.push(devHandler);
};

const BuiltInProviders = [
  "cloudflare",
  "cloudimage",
  "cloudinary",
  "contentful",
  "directus",
  "edgio",
  "fastly",
  "glide",
  "gumlet",
  "imageengine",
  "imagekit",
  "imgix",
  "ipx",
  "layer0",
  "netlify",
  "none",
  "prismic",
  "sanity",
  "storyblok",
  "strapi",
  "twicpics",
  "unsplash",
  "vercel",
  "wagtail"
];
const providerSetup = {
  // IPX
  ipx: ipxSetup,
  static: ipxSetup,
  // https://vercel.com/docs/more/adding-your-framework#images
  vercel(_providerOptions, moduleOptions, nuxt) {
    nuxt.options.nitro = defu(nuxt.options.nitro, {
      vercel: {
        config: {
          images: {
            domains: moduleOptions.domains,
            minimumCacheTTL: 60 * 5,
            sizes: Array.from(new Set(Object.values(moduleOptions.screens || {})))
          }
        }
      }
    });
  }
};
async function resolveProviders(nuxt, options) {
  const providers = [];
  for (const key in options) {
    if (BuiltInProviders.includes(key)) {
      providers.push(await resolveProvider(nuxt, key, { provider: key, options: options[key] }));
    }
  }
  for (const key in options.providers) {
    providers.push(await resolveProvider(nuxt, key, options.providers[key]));
  }
  return providers;
}
async function resolveProvider(_nuxt, key, input) {
  if (typeof input === "string") {
    input = { name: input };
  }
  if (!input.name) {
    input.name = key;
  }
  if (!input.provider) {
    input.provider = input.name;
  }
  const resolver = createResolver(import.meta.url);
  input.provider = BuiltInProviders.includes(input.provider) ? await resolver.resolve("./runtime/providers/" + input.provider) : await resolvePath(input.provider);
  const setup = input.setup || providerSetup[input.name];
  return {
    ...input,
    setup,
    runtime: normalize(input.provider),
    importName: `${key}Runtime$${hash(input.provider)}`,
    runtimeOptions: input.options
  };
}
function detectProvider(userInput) {
  if (process.env.NUXT_IMAGE_PROVIDER) {
    return process.env.NUXT_IMAGE_PROVIDER;
  }
  if (userInput && userInput !== "auto") {
    return userInput;
  }
  if (provider === "vercel") {
    return "vercel";
  }
}

const module = defineNuxtModule({
  defaults: (nuxt) => ({
    inject: false,
    staticFilename: "[publicPath]/image/[hash][ext]",
    provider: "auto",
    dir: nuxt.options.dir.public,
    presets: {},
    domains: [],
    sharp: {},
    // https://tailwindcss.com/docs/breakpoints
    screens: {
      xs: 320,
      sm: 640,
      md: 768,
      lg: 1024,
      xl: 1280,
      xxl: 1536,
      "2xl": 1536
    },
    internalUrl: "",
    providers: {},
    alias: {}
  }),
  meta: {
    name: "@nuxt/image",
    configKey: "image",
    compatibility: {
      nuxt: "^3.1.0"
    }
  },
  async setup(options, nuxt) {
    const resolver = createResolver(import.meta.url);
    options.dir = resolve(nuxt.options.srcDir, options.dir);
    options.domains = options.domains.map((d) => {
      if (!d.startsWith("http")) {
        d = "http://" + d;
      }
      return parseURL(d).host;
    }).filter(Boolean);
    options.alias = Object.fromEntries(Object.entries(options.alias).map((e) => [withLeadingSlash(e[0]), e[1]]));
    options.provider = detectProvider(options.provider);
    if (options.provider) {
      options[options.provider] = options[options.provider] || {};
    }
    const imageOptions = pick(options, [
      "screens",
      "presets",
      "provider",
      "domains",
      "alias"
    ]);
    const providers = await resolveProviders(nuxt, options);
    for (const p of providers) {
      if (typeof p.setup === "function" && p.name !== "ipx") {
        await p.setup(p, options, nuxt);
      }
    }
    const runtimeDir = resolver.resolve("./runtime");
    nuxt.options.alias["#image"] = runtimeDir;
    nuxt.options.build.transpile.push(runtimeDir);
    addImports({
      name: "useImage",
      from: resolver.resolve("runtime/composables")
    });
    addComponent({
      name: "NuxtImg",
      filePath: resolver.resolve("./runtime/components/nuxt-img")
    });
    addComponent({
      name: "NuxtPicture",
      filePath: resolver.resolve("./runtime/components/nuxt-picture")
    });
    addTemplate({
      filename: "image-options.mjs",
      getContents() {
        return `
${providers.map((p) => `import * as ${p.importName} from '${p.runtime}'`).join("\n")}

export const imageOptions = ${JSON.stringify(imageOptions, null, 2)}

imageOptions.providers = {
${providers.map((p) => `  ['${p.name}']: { provider: ${p.importName}, defaults: ${JSON.stringify(p.runtimeOptions)} }`).join(",\n")}
}
        `;
      }
    });
    nuxt.hook("nitro:init", async (nitro) => {
      if (!options.provider || options.provider === "ipx") {
        imageOptions.provider = options.provider = nitro.options.node ? "ipx" : "none";
        options[options.provider] = options[options.provider] || {};
        if (options.provider === "none") {
          return;
        }
        const p = await resolveProvider(nuxt, "ipx", options.ipx);
        if (!providers.some((p2) => p2.name === "ipx")) {
          providers.push(p);
        }
        if (typeof p.setup === "function") {
          await p.setup(p, options, nuxt);
        }
      }
    });
    if (options.inject) {
      addPlugin({ src: resolver.resolve("./runtime/plugin") });
    }
  }
});
function pick(obj, keys) {
  const newobj = {};
  for (const key of keys) {
    newobj[key] = obj[key];
  }
  return newobj;
}

export { module as default };
